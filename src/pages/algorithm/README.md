# 算法

## 时间复杂度
### 算法的好与坏
- 衡量算法好坏的重要标准有两个，时间复杂度和空间复杂度(如：运行时间长占用空间大)
- 常数时间O(1)代表这个操作和数据量没关系，是一个固定时间的操作，比如说四则运算。

- 对于一个算法来说，可能会计算出如下操作次数aN + 1，N代表数据量。那么该算法的时间复杂度就是 O(N)。因为我们在计算时间复杂度的时候，数据量通常是非常大的，这时候低阶项和常数项可以忽略不计。

- 当然可能会出现两个算法都是 O(N) 的时间复杂度，那么对比两个算法的好坏就要通过对比低阶项和常数项了。

### 基本操作执行次数
1. `T(n) = 3n` 执行次数是线性的
2. `T(n) = 5logn` 执行次数是对数计算的
3. `T(n) = 2` 执行次数是常量
4. `T(n) = 0.5(n * n) + o.5n` 执行次数是用多项式计算的

### 渐进时间复杂度
- 若存在函数f(n),使得当n(n为输入规模)趋近于无穷大时，`T(n)/f(n)`的极限值为不等于0的常数，则称f(n)是T(n)的同数量级函数，记做`T(n)=O(f(n))`,称为`O(f(n))
`，O为算法的渐进时间复杂度，简称为时间复杂度
- 时间复杂度就是把程序的相对执行时间函数T(n)简化为一个数量级，这个数量级可以是`n、(n * n)、(n * n * n)`, 推导时间复杂度的原则是：
1. 如果运行时间是常数量级，则用常数1表示
2. 只保留时间函数中的最高阶项
3. 如果最高阶项存在，则省去最高阶项前面的系数
```js
// 如：
T(n) = 3n
// 最高阶项为3n, 省去系数3，则转化的时间复杂度为： T(n)=O(n)

T(n) = 5logn
// 最高阶项为5logn, 省去系数5，则转化的时间复杂度为： T(n)=O(logn)

T(n) = 2
// 只有常数量级，则转化的时间复杂度为：T(n)=O(1)

T(n) = 0.5(n * n) + 0.5n
// 最高阶项为0.5(n * n), 省去系数0.5，则转化的时间复杂度为： T(n)=O(n * n)
```
<font color='red'><b>这4中时间复杂度谁的执行用时最长呢？<br> O(1) < O(logn) < O(n) < O(n * n)</b></font>

### 时间复杂度的差距
- 举例如下：
1. 算法A的执行次数是`T(n) = 100n`, 时间复杂度是O(n)
2. 算法B的执行次数是`T(n) = 5(n * n)`, 时间复杂度是O(n * n)
- 那么随着输入规模n的增长，两种算法的运行速度如下：

<img src="/imgs/algo1.png">

- 从上面的表格可以看出，当n的值很小时，算法A的运行时间要远大于算法B，当n的值在1000左右时，算法A和算法B的运行时间已经比较接近，随着n的值越来越大，甚至达到十万、百万时，算法A的优势就开始显现出来，算法B
的运行时间越来越慢，差距越来越明显，这就是不同时间复杂度带来的差距 


## 空间复杂度
- 空间复杂度是对一个算法在运行过程中临时占用存储空间大小的度量，它同样使用了大O表示法，程序占用空间大小的计算公式为`S(n)=O(f(n))`,其中n为问题的规模，f(n)为算法所占存储空间的函数

### 空间复杂度的计算
1. 常量空间：当算法的存储空间大小固定，和输入规模没有直接的关系时，空间复杂度为`O(1)`
2. 线性空间：当算法分配的空间是一个线性的集合(如：数组)，并且集合大小和输入规模n成正比时，空间复杂度为`O(n)`
3. 二维空间：当算法分配的空间是一个二维数组集合，并且集合的长度和宽度都与输入规模n成正比时，空间复杂度为`O(n * n)`
4. 递归空间：递归是一个比较特殊的场景，虽然递归代码中并没有显式地声明变量或集合，但是计算机在执行程序时，会专门分配一块内存，用来存储"方法调用栈"(方法调用栈包括进栈和出栈两个行为)
，执行递归操作所需要的内存空间和递归的深度成正比，纯粹的递归操作的空间复杂度也是线性的，如果递归的深度是n，那么空间复杂度为`O(n)`

### 时间与空间的取舍
- 计算机的运行速度和空间资源是有限的，在绝大多数的时候，时间复杂度更为重要一些，宁可多分配一些内存空间，也要提升程序的执行速度


## 算法分类

### 时间复杂度为O(n^2)的排序算法
1. 冒泡排序
2. 选择排序
3. 插入排序
4. 希尔排序(希尔排序比较特殊，它的性能略优于O(n^2),但是又比不上O(nlogn), 姑且把它归入本类)

### 时间复杂度为O(nlogn)的排序算法
1. 快速排序
2. 归并排序
3. 堆排序

### 时间复杂度为线性的排序算法
1. 计数排序
2. 桶排序
3. 基数排序

- 以上列举的为主流的排序算法，还有更多五花八门的排序，此外，排序算法还可以根据其稳定性，划分为稳定排序和不稳定排序
- 如果值相同的元素在排序后仍然保持着排序前的顺序，则这样的排序算法是稳定排序，如果值相同的元素在排序后打乱了排序前的顺序，则这样的排序算法是不稳定排序，如：
<img src="/imgs/alg-stable.png">

## 排序算法

### 冒泡排序
- 冒泡排序是一种稳定排序，值相等的元素并不会打乱原本的顺序，由于该排序算法的每一轮都要遍历所有元素，总共遍历(元素数量-1)轮，所以平均时间复杂度为O(n^2)






<style>
#app .theme-default-content {
    max-width: 1200px;
}
</style>
