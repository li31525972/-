# 网络
## 从输入URL到页面加载完成的过程
<img align='center' src="../../static/imgs/url-analyse.png" />

1. 首先是从URL中解析出域名进行DNS查询，如果这一步做了智能DNS解析的话，会提供访问速度最快的IP地址回来，否则需要一级一级进行查询，从跟服务器、一级域名、二级域名依次进行查询;

2. 浏览器端的所有请求本质都是`HTTP`请求，底层都是`TCP/IP`协议，浏览器根据请求返回的`Content-type`来决定如何解析数据;

3. 接下来是`TCP`握手，应用层会下发数据给传输层，这里`TCP`协议会指明两端的端口号，然后下发给网络层。网络层中的`IP`协议会确定`IP`地址，并且指示了数据传输中如何跳转路由器。然后包会再被封装到数据链路层的数据帧结构中，最后就是物理层面的传输了

4. `TCP`握手结束后会进行`TLS`握手，然后就开始正式的传输数据;

5. 数据在进入服务端之前，可能还会先经过负责负载均衡的服务器，它的作用就是将请求合理的分发到多台服务器上，这时假设服务端会响应一个`HTML`文件;

6. 首先浏览器会判断状态码是什么，如果是200那就继续解析，如果400或500的话就会报错，如果300的话会进行重定向，这里会有个重定向计数器，避免过多次的重定向，超过次数也会报错;

7. 浏览器开始解析文件，如果是`gzip`格式的话会先解压一下，然后通过文件的编码格式知道该如何去解码文件;

8. 文件解码成功后会正式开始渲染流程，先会根据`HTML`构建`DOM`树，有`CSS`的话会去构建`CSSOM`树。如果遇到`script`标签的话，会判断是否存在`async`或者`defer` ，前者会并行进行下载并执行JS（不会操作DOM），后者会先下载文件，然后等待`HTML`解析完成后顺序执行，如果以上都没有，就会阻塞住渲染流程直到JS执行完毕。遇到文件下载的会去下载文件，这里如果使用`HTTP 2.0`协议的话会极大的提高多图的下载效率。

9. 初始的`HTML`被完全加载和解析后会触发`DOMContentLoaded`事件;

10. `CSSOM`树和`DOM`树构建完成后会开始生成`Render`树，这一步就是确定页面元素的布局、样式等等诸多方面的东西;

11. 在生成`Render`树的过程中，浏览器就开始调用`GPU`绘制，合成图层，将内容显示在屏幕上了;

## OSI 概念模型
- OSI(`Open System Interconnection Reference Model`)
1. 应用层，如HTTP等协议，解决的是业务问题
2. 表示层，主要是把网络中的消息转换成应用层可以读取的消息
3. 会话层，建立回话、握手、关闭
4. 传输层，进程与进程之间的通讯
5. 网络层，把报文从一个主机上发送到另外一个主机上，就是现在的`Internet`
6. 数据链路层，在局域网中使用Mac地址连接到相应的交换机或者路由器把报文转到另一个主机上
7. 物理层，物理的介质

## 响应码规范
### `1xx`
<b>请求已接收到，需要进一步处理才能完成，`HTTP1.0`不支持</b>
- `100 Continue`：上传大文件前使用
> 由客户端发起请求中携带 Expect: 100-continue 头部触发
- `101 Switch Protocols`: 协议升级使用
> 由客户端发起请求中携带 Upgrade: 头部触发，如升级 websocket 或者 http/2.0
- `102 Processing` WebDAV 请求可能包含许多涉及文件操作的子请求，需要很长时间才能完成请求，该代码表示服务器已经收到并正在处理请求，但无响应可用，这样可以防止客户端超时，并假设请求丢失

### `2xx` 成功处理请求
- `200 OK` 成功返回响应
- `201 Created` 有新资源在服务器端被成功创建
- `202 Accepted` 服务器接收并开始处理请求，但请求未处理完成
> 例如异步、需要长时间处理的任务
- `203 Non-Authoritative Information` 当代理服务器修改了`origin server`的原始响应包体时(例如奉还了HTML中的元素值)
> 代理服务器可以通过修改200为203的方式告知客户端这一事实，方便客户端为这一行为作出相应的处理，203响应可以被缓存
- `204 No Contnet` 成功执行了请求且不携带响应包体，并按时客户端无需更新当前的页面视图
- `205 Reset Content` 成功执行了请求且不携带响应包体，同时指明客户端需要更新当前页面视图
- `206 Partial Content` 使用`range`协议时返回部分响应内容时的响应码
> 主要用于多线程断点续传、下载等
- `207 Multi-Status` `RFC4918`,在WEBDAV协议中以XML返回多个资源的状态
- `208 Already Reported` RFC5842，为避免相同集合下资源在207响应码下重复上报，使用208可以使用父集合的响应码

### `3xx` 重定向
<b>重定向使用`Location`指向的资源或者缓存中的资源，在`RFC2068`中规定客户端重定向次数不应超过5次，以防止死循环</b>
- `300 Multiple Choices` 资源有多种表述，通过300返回给客户端后由其自行选择访问哪一种表述，由于缺乏明确的细节，300很少使用
- `301 Moved Permanently` 资源永久性的重定向到另一个URI中
> 浏览器可以对永久性的重定向直接缓存
- `302 Found` 资源临时性的重定向到另一个URI中
- `303 See Other` 重定向到其它资源，常用语POST/PUT等方法的响应中
- `304 Not Modified` 当客户端拥有可能过期的缓存时，会携带缓存的标识`etag`、事件等信息询问服务器缓存是否仍可复用，而304是告诉客户端可以复用缓存
- `307 Temporary Redirect` 类似302，但明确重定向后请求方法必须与原请求方法相同，不得改变
- `308 Permanent Redirect` 类似301，但明确重定向后请求方法必须与原请求方法相同，不得改变

### `4xx` 客户端错误
- `400 Bad Request` 服务器认为客户端出现了错误，但不能明确判断为以下哪种错误时使用此错误码，例如HTTP请求格式错误
- `401 Unauthorized` 用户认证信息缺失或者不正确，导致服务器无法处理请求
- `403 Forbidden` 服务器理解请求的含义，但没有权限执行此请求
- `404 Not Found` 服务器没有找到对应的资源
- `405 Method Not Allowed` 服务器不支持请求行中的`method`方法
- `406 Not Acceptable` 对客户端指定的资源表述不存在(例如对语言或者编码有要求)，服务器返回表述列表供客户端选择
- `407 Proxy Authentication Required` 对需要经由代理的请求，认证信息未通过代理服务器的认证
- `408 Request Timeout` 服务器接收请求超时
- `409 Conflict` 资源冲突，例如上传文件时目标位置已经存在版本更新的资源
- `410 Gone` 服务器没有找到对应的资源，且明确知道该位置永久性的找不到该资源
- `411 Length Required` 如果请求含有包体且未携带`Content-Length`头部，且不属于chunk类请求是，返回411
- `412 Precondition Failed` 复用缓存时传递的if-Unmodified-since或if-None-Match头部不被满足
> 条件类请求不满足时返回412
- `413 Payload Too Large/Request Entity Too Large` 请求的包体超出服务器能处理的最大长度
- `414 URI Too Long` 请求的URI超出服务器能接受的最大长度
> 老版本的服务器通常接收为4K，新版本的Nginx能接受32K
- `415 Unsupported Media Type` 上传的文件类型不被服务器支持
- `416 Range Not Satisfiable` 无法提供Range请求中指定的那段包体
- `417 Expectation Failed` 对于`Expect`请求头部期待的情况无法满足时的响应码
> 比如100那种需要上传一个大文件时想要返回一个100状态码，但是服务器不支持就会返回417
- `421 Misdirected Request` 服务器认为这个请求不该发给它，因为它没有能力处理
> 基本见不到
- `426 Upgrade Required` 服务器拒绝基于当前HTTP协议提供内容(比如HTTP1.0)，通过Upgrade头部告知客户端必须升级协议才能继续处理
- `428 Precondition Required` 用户请求中缺失了条件类头部，例如if-Match
- `429 Too Many Requests` 客户端发送请求的速率过快
> 注意：目前市面上服务器限流限速的时候通常不按照这个规范，而是发送503
- `431 Request Header Fields Too Large` 请求的HEADER头部大小超过限制
- `451 Unavailable For Legal Reasons` RFC7725，由于法律原因资源不可访问
> 基本为商业原因非技术原因

### `5xx` 服务器错误
- `500 Internal Server Error` 服务器内部错误，且不属于以下错误类型
- `501 Not Implemented` 服务器不支持实现请求所需要的功能
- `502 Bad Gateway` 代理服务器无法获取到合法响应
> 在与原服务器之间有代理服务器，但是代理服务器连接不上原服务器或代理服务器无法在原服务器中获取到合法的响应
- `503 Service Unavailable` 服务器资源尚未准备好处理当前请求
> 分很多情况比如：服务器端做请求的限速、对用户的IP做并发连接限制等，当达到了上限都可能会发503
- `504 Gateway Timeout` 代理服务器无法及时的从上游获得响应
> 比如上传了一个很大的文件，而Nginx服务器设置的超时时间是一分钟，那么代理服务器没有及时接受到响应，就会返回504
- `505 HTTP Version Not Supported` 请求使用的HTTP协议版本不支持
> 比如某些服务器不支持HTTP2.0就会返回505，基本见不到了
- `507 Insufficient Storage` 服务器没有足够的空间处理请求
> 通常指磁盘空间，但是会将服务器内部的相关问题暴露给客户端，会有安全性的问题，所以基本见不到
- `508 Loop Detected` 访问资源时检测到循环或者循环已经超过了最大次数了
- `511 NetWork Authentication Required` 代理服务器发现客户端需要进行身份验证才能获得网络访问权限

<p><font color='red'><b>如果客户端遇到了不认识的响应码，那么就会按照该系列的x00状态码处理</b></font></p>

## 请求头
### User-Agent
- 指明客户端的类型信息，服务器可以据此对资源的表述做抉择，例如：
```js
// Chrome 发出的
user-agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_3) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.132 Safari/537.36
/*
*   Mozilla/5.0 表示兼容 Mozilla 版本
*   (Macintosh; Intel Mac OS X 10_14_3) 表示运行在什么系统上，以及系统的版本
*   AppleWebKit/537.36 表示渲染引擎以及版本号
*   (KHTML, like Gecko) 表示和 Firefox 渲染引擎很相似
*   Chrome/80.0.3987.132 Safari/537.36 浏览器的版本号，Chrome和Safari使用的是同一个渲染引擎
*/
```

### Referer
- 浏览器对来自某一页面的请求自动添加的头部(表示当前的请求来自另一个页面)
```js
// 例如：
Referer: https://www.baidu.com/
```
- `Referer`不被添加的场景
1. 来源页面采用的协议为表示本地文件的`file`或者`data`URI
2. 当前请求页面采用的是HTTP协议，而来源页面采用的是HTTPS协议
<p><font color='red'><b>服务器端主要的用途有3种：统计分析、缓存优化、防盗链</b></font></p>
- 统计分析：比如统计我们的页面是来自搜索引擎还是来自某些入口流量中
- 缓存优化：比如只对某些来源才做相应的缓存
- 防盗链：比如有些资源不想被其它站点直接引用，那么就可以阻止这个请求的访问

### From
- 主要用于网络爬虫，告诉服务器运维人员如何通过邮件联系到爬虫的负责人
```js
// 例如可以通过下面邮箱地址联系到爬虫的负责人：
From：xxx@xxx.com
```

## 响应头
### Server
- 指明服务器上所使用软件的信息，用于帮助客户端定位问题或者统计数据

## HTTP
### 什么是HTTP协议？
- `HTTP`是一种无状态的、应用层的、以请求/应答方式运行的协议，它使用可扩展的语义和字描述消息格式，与基于网络的超文本信息系统灵活的互动

### HTTP解决了什么问题
1. 低门槛
2. 可扩展性：巨大的用户群体，超长的寿命
3. 分布式系统下的`Hypermedia`: 大粒度数据的网络传输(视频、音乐等)
4. `Internet`规模
---
* 无法控制的`scalability`
> 不可预测的负载、非法格式的数据、恶意消息 
> 客户端不能保持所有服务器信息，服务器不能保持多个请求间的状态信息
* 独立的组件部署：新老组件并存

5. 向前兼容：自1993年起HTTP0.9/1.0(1996)已经被广泛使用

### HTTP常见方法
- `GET` 主要的获取信息的方法，大量的性能优化都针对该方法，幂等方法
- `HEAD` 类似`GET`的方法，但服务器不发送`BODY`，用于获取`HEAD`元数据，幂等方法
- `POST` 常用于`HTML FORM`表单提交，新增资源
- `PUT` 更新资源，带条件时是幂等方法
- `DELETE` 删除资源，幂等方法
- `CONNECT` 建立`tunnel`隧道
- `OPTIONS` 显示服务器对访问资源支持的方法，幂等方法
- `TRACE` 回显服务器接收到的请求，用于定位问题，有安全风险
<p><font color='red'><b>什么是幂等方法：就是调用一次和调用多次的结果是一样的</b></font></p>

### HTTP连接的常见流程
1. 浏览器解析出主机名
2. 浏览器查询这个主机名的IP地址(DNS)
3. 浏览器获得端口号
4. 浏览器发起到xxx.xx.xx.x端口xx的连接
5. 浏览器向服务器发送一条`HTTP GET`报文
6. 浏览器从服务器读取`HTTP`响应报文
7. 浏览器关闭连接

### 长连接和短连接
#### 需要先知道事务的概念：假定一个请求对应一个响应就是一个事务
- 短连接就是每建立一个连接1，处理一个请求得到一个响应，连接关闭，然后建立连接2，发送请求，得到响应，再关闭，这就是短连接
- 长连接就是客户端与服务器建立了一个连接，执行完了一个事务之后又执行第二个事务、第三个事务、第四个事务，一直在一个连接上，这就是长连接

<b>那么长连接由什么决定呢？</b>
#### `Connection`头部 HTTP/1.1引入的
- 在为`Connection`头部添加了`Keep-Alive`这个值时，就表示长连接(仅表示客户端与代理服务器之间)
> 客户端请求中携带 Connection: Keep-Alive 表示使用长连接 <br>
> 服务器响应中携带 Connection: Keep-Alive 表示支持长连接 <br>
- 在`HTTP/1.1`中默认支持长连接，`Connection: Keep-Alive`就没有意义
> 那么如果不使用长连接呢？如HTTP1.1 那么就在 Connection: Close 表示不使用长连接
#### <p><font color='red'><b>Connection头部的其它功能</b></font></p>
- 对代理服务器有一些要求
> 代理服务器在转发请求的时候请不要转发在 Connection 中列出的头部，比如 Connection 中有 Cookie，那么在转发时要将 Cookie 去除掉

#### 如果不支持 `Connection` 头部，比如老旧的服务器
- 使用 `Proxy-Connection`

## HTTP2.0

## HTTPS

## TLS/SSL

## TCP

## IP

## 应用常见问题

### 为什么要进行URI编码
- 传递数据中，如果存在用作分隔符的保留字符怎么办？

- 对可能产生歧义性的数据编码
1. 不在ASCII码范围内的字符
2. ASCII码中不可显示的字符
3. URI中规定的保留字符`: / ? # [ ] @ ! $ & ' ( ) * + , ; =`等等
4. 不安全字符(传输环节中可能被不正确的处理)，如：空格、引号、尖括号等
